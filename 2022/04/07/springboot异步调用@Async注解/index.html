<!DOCTYPE html><html><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><title>springboot异步调用@Async注解 | FreeTime</title><meta name=author content=ljj><meta name=copyright content=ljj><meta name=keywords content=spring><meta name=description content="背景当访问其他人的接口较慢或者做耗时任务时，不想程序一直卡在耗时任务上，想程序能够并行执行，我们可以使用多线程来并行的处理任务，也可以使用spring提供的异步处理方式@Async。 配置启动类增加EnableAsync注解 123456789...@EnableAsync...public class SingleApplication &amp;#123;    public static void"><meta property=og:type content=article><meta property=og:title content=springboot异步调用@Async注解><meta property=og:url content=https://example.com/2022/04/07/springboot%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8@Async%E6%B3%A8%E8%A7%A3/ ><meta property=og:site_name content=FreeTime><meta property=og:description content="背景当访问其他人的接口较慢或者做耗时任务时，不想程序一直卡在耗时任务上，想程序能够并行执行，我们可以使用多线程来并行的处理任务，也可以使用spring提供的异步处理方式@Async。 配置启动类增加EnableAsync注解 123456789...@EnableAsync...public class SingleApplication &amp;#123;    public static void"><meta property=og:locale content=zh_CN><meta property=og:image content=https://example.com/img/logo.gif><meta property=article:published_time content=2022-04-06T16:13:43.000Z><meta property=article:modified_time content=2022-04-09T05:26:41.808Z><meta property=article:author content=ljj><meta property=article:tag content=spring><meta name=twitter:card content=summary><meta name=twitter:image content=https://example.com/img/logo.gif><meta http-equiv=Cache-Control content=no-siteapp><link href=//cdn.jsdelivr.net rel=preconnect><link href=https://example.com rel=prefetch><link href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css rel=stylesheet><link href=/css/main.css rel=stylesheet><script src=/js/utlis.js></script><meta name=generator content="Hexo 6.1.0"></head><body><script>var $config={tocStyle:"visible",CDN:{fancyboxJs:"https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js",fancyboxCss:"https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css"},searchFile:"/search.xml"}</script><div id=body-wrap><nav id=nav-wrap><div class=navbar><div class=bar><a href=/ class=title>ljj'blog</a> <i class="fas fa-search search-btn"></i><ul class=menu><li><a href=/ >首页</a></li><li><a class=menu-child-hover href=javascript:void(0);>找文章</a><ul class=menu-child><li><a href=/tags>标签</a></li><li><a href=/categories>分类</a></li><li><a href=/archives>归档</a></li></ul></li><li><a href=/link>友情链接</a></li><li><a href=/about>关于我</a></li></ul><i class="fas fa-bars open-nav"></i></div></div><div id=mobile-nav><ul><li><a href=/ >首页</a></li><li><a href=/tags>标签</a></li><li><a href=/categories>分类</a></li><li><a href=/archives>归档</a></li><li><a href=/link>友情链接</a></li><li><a href=/about>关于我</a></li></ul></div></nav><main id=main><article id=post><div class=post-info><div class=post-title><h1>springboot异步调用@Async注解</h1></div><div class=post-meta><div class=post-date><i class="far fa-calendar-alt fa-fw post-meta-icon"></i> <span class=post-meta-label>发表于 2022-04-07 | </span><i class="fas fa-history fa-fw post-meta-icon"></i> <span class=post-meta-label>更新于 2022-04-12</span></div><div class=post-meta-wordcount><i class="far fa-file-word fa-fw post-meta-icon"></i> <span class=post-meta-label>总字数:</span> <span class=word-count>1.4k | </span><i class="far fa-clock fa-fw post-meta-icon"></i> <span class=post-meta-label>阅读时长:</span> <span>6分钟</span></div></div></div><div class=post-content><h2 id=背景><a href=#背景 class=headerlink title=背景></a>背景</h2><p>当访问其他人的接口较慢或者做耗时任务时，不想程序一直卡在耗时任务上，想程序能够并行执行，我们可以使用多线程来并行的处理任务，也可以使用spring提供的异步处理方式@Async。</p><h2 id=配置><a href=#配置 class=headerlink title=配置></a>配置</h2><p>启动类增加EnableAsync注解</p><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre></td><td class=code><pre><span class=line>...</span><br><span class=line>@EnableAsync</span><br><span class=line>...</span><br><span class=line>public class SingleApplication &#123;</span><br><span class=line>    public static void main(String[] args) &#123;</span><br><span class=line>            SpringApplication.run(SingleApplication.class, args);</span><br><span class=line>    </span><br><span class=line>    &#125;</span><br><span class=line>...</span><br></pre></td></tr></table></figure><h2 id=错误示范><a href=#错误示范 class=headerlink title=错误示范></a>错误示范</h2><p>同类方法中使用异步注解没有作用,这样执行后就,是串行单线程</p><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br></pre></td><td class=code><pre><span class=line></span><br><span class=line>package com.web.rest.controller;</span><br><span class=line> </span><br><span class=line>import org.slf4j.Logger;</span><br><span class=line>import org.slf4j.LoggerFactory;</span><br><span class=line>import org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line>import org.springframework.scheduling.annotation.Async;</span><br><span class=line>import org.springframework.web.bind.annotation.GetMapping;</span><br><span class=line>import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=line>import org.springframework.web.bind.annotation.RestController;</span><br><span class=line> </span><br><span class=line>/**</span><br><span class=line> * 描述: 测试异步调用;</span><br><span class=line> * 测试多线程调用</span><br><span class=line> *</span><br><span class=line> */</span><br><span class=line>@RestController</span><br><span class=line>@RequestMapping(&quot;/&quot;)</span><br><span class=line>public class AsyncController &#123;</span><br><span class=line> </span><br><span class=line>    private  final Logger log =  LoggerFactory.getLogger(this.getClass());</span><br><span class=line> </span><br><span class=line>    @Autowired</span><br><span class=line>    private AsyncControllerTest asyncControllerTest;</span><br><span class=line> </span><br><span class=line>    /**</span><br><span class=line>     * @Description //方法调用接口类</span><br><span class=line>     * @param</span><br><span class=line>     * @return java.lang.String</span><br><span class=line>     **/</span><br><span class=line>    @GetMapping(&quot;test&quot;)</span><br><span class=line>    public String test()&#123;</span><br><span class=line>//        asyncControllerTest.doAsyncMethod();</span><br><span class=line>//        asyncControllerTest.doAsyncMethod();</span><br><span class=line>        doAsyncMethod();</span><br><span class=line>        doAsyncMethod();</span><br><span class=line>        log.debug(&quot;主线程执行结束......&quot;);</span><br><span class=line>        return &quot;SUCCESS&quot;;</span><br><span class=line>    &#125;</span><br><span class=line> </span><br><span class=line>    /**</span><br><span class=line>     * @Description //同类方法中的异步标签</span><br><span class=line>     * @param</span><br><span class=line>     * @return void</span><br><span class=line>     **/</span><br><span class=line>    @Async</span><br><span class=line>    private void doAsyncMethod() &#123;</span><br><span class=line>        try &#123;</span><br><span class=line>            //todo</span><br><span class=line>            Thread.sleep(2000);</span><br><span class=line>            log.debug(&quot;异步方法执行了......&quot;);</span><br><span class=line>        &#125;catch (Exception e)&#123;</span><br><span class=line>            e.printStackTrace();</span><br><span class=line>        &#125;</span><br><span class=line>    &#125;</span><br><span class=line> </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h2 id=正确做法><a href=#正确做法 class=headerlink title=正确做法></a>正确做法</h2><p>改正使用调用另外的类,然后通过注入的方式注入对象:</p><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br></pre></td><td class=code><pre><span class=line></span><br><span class=line>package com.web.rest.controller;</span><br><span class=line> </span><br><span class=line>import org.slf4j.Logger;</span><br><span class=line>import org.slf4j.LoggerFactory;</span><br><span class=line>import org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line>import org.springframework.scheduling.annotation.Async;</span><br><span class=line>import org.springframework.web.bind.annotation.GetMapping;</span><br><span class=line>import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=line>import org.springframework.web.bind.annotation.RestController;</span><br><span class=line> </span><br><span class=line>/**</span><br><span class=line> * 描述: 测试异步调用;</span><br><span class=line> * 测试多线程调用</span><br><span class=line> *</span><br><span class=line> */</span><br><span class=line>@RestController</span><br><span class=line>@RequestMapping(&quot;/&quot;)</span><br><span class=line>public class AsyncController &#123;</span><br><span class=line> </span><br><span class=line>    private  final Logger log =  LoggerFactory.getLogger(this.getClass());</span><br><span class=line> </span><br><span class=line>    @Autowired</span><br><span class=line>    private AsyncControllerTest asyncControllerTest;</span><br><span class=line> </span><br><span class=line>    /**</span><br><span class=line>     * @Description //方法调用接口类</span><br><span class=line>     * @param</span><br><span class=line>     * @return java.lang.String</span><br><span class=line>     **/</span><br><span class=line>    @GetMapping(&quot;test&quot;)</span><br><span class=line>    public String test()&#123;</span><br><span class=line>        asyncControllerTest.doAsyncMethod();</span><br><span class=line>        asyncControllerTest.doAsyncMethod();</span><br><span class=line>//        doAsyncMethod();</span><br><span class=line>//        doAsyncMethod();</span><br><span class=line>        log.debug(&quot;主线程执行结束......&quot;);</span><br><span class=line>        return &quot;SUCCESS&quot;;</span><br><span class=line>    &#125;</span><br><span class=line> </span><br><span class=line>    /**</span><br><span class=line>     * @Author Young</span><br><span class=line>     * @Description //同类方法中的异步标签</span><br><span class=line>     * @Date 16:45 2019/3/11</span><br><span class=line>     * @param</span><br><span class=line>     * @return void</span><br><span class=line>     **/</span><br><span class=line>    @Async</span><br><span class=line>    private void doAsyncMethod() &#123;</span><br><span class=line>        try &#123;</span><br><span class=line>            //todo</span><br><span class=line>            Thread.sleep(2000);</span><br><span class=line>            log.debug(&quot;异步方法执行了......&quot;);</span><br><span class=line>        &#125;catch (Exception e)&#123;</span><br><span class=line>            e.printStackTrace();</span><br><span class=line>        &#125;</span><br><span class=line>    &#125;</span><br><span class=line> </span><br><span class=line>&#125;</span><br><span class=line></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre></td><td class=code><pre><span class=line>package com.web.rest.controller;</span><br><span class=line> </span><br><span class=line>import org.slf4j.Logger;</span><br><span class=line>import org.slf4j.LoggerFactory;</span><br><span class=line>import org.springframework.scheduling.annotation.Async;</span><br><span class=line>import org.springframework.stereotype.Component;</span><br><span class=line> </span><br><span class=line>/**</span><br><span class=line> * 描述:异步类</span><br><span class=line> *</span><br><span class=line> */</span><br><span class=line>@Component</span><br><span class=line>public class AsyncControllerTest &#123;</span><br><span class=line> </span><br><span class=line> </span><br><span class=line>    private  final Logger log =  LoggerFactory.getLogger(this.getClass());</span><br><span class=line> </span><br><span class=line>    @Async</span><br><span class=line>    public void doAsyncMethod() &#123;</span><br><span class=line>        try &#123;</span><br><span class=line>            //todo</span><br><span class=line>            Thread.sleep(2000);</span><br><span class=line>            log.debug(&quot;异步方法执行了......&quot;);</span><br><span class=line>        &#125;catch (Exception e)&#123;</span><br><span class=line>            e.printStackTrace();</span><br><span class=line>        &#125;</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h4 id=究其原因><a href=#究其原因 class=headerlink title=究其原因:></a>究其原因:</h4><p>简单说就是没有过去到代理类,本类调用时,直接自己内部调用,没有走代理类</p><h5 id=一般导致-Async失效原因><a href=#一般导致-Async失效原因 class=headerlink title=一般导致@Async失效原因></a>一般导致@Async失效原因</h5><p>1.没有在@SpringBootApplication启动类当中添加注解@EnableAsync注解。<br>2.异步方法使用注解@Async的返回值只能为void或者Future。<br>3.没有走Spring的代理类。因为@Transactional和@Async注解的实现都是基于Spring的AOP，而AOP的实现是基于动态代理模式实现的。那么注解失效的原因就很明显了，有可能因为调用方法的是对象本身而不是代理对象，因为没有经过Spring容器。</p><h2 id=升华><a href=#升华 class=headerlink title=升华></a>升华</h2><h4 id=如何在本类中调用><a href=#如何在本类中调用 class=headerlink title=如何在本类中调用></a>如何在本类中调用</h4><p>这里具体说一下 (导致@Async失效原因) 第三种情况的解决方法。<br>1.注解的方法必须是public方法。<br>2.方法一定要从另一个类中调用，也就是从类的外部调用，类的内部调用是无效的。<br>3.如果需要从类的内部调用，需要先获取其代理类，下面上代码</p><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre></td><td class=code><pre><span class=line></span><br><span class=line>@Service</span><br><span class=line>public class XxxService&#123;</span><br><span class=line>  public void methodA()&#123;</span><br><span class=line>    ...</span><br><span class=line>    XxxService xxxServiceProxy = SpringUtil.getBean(XxxService.class);</span><br><span class=line>    xxxServiceProxy.methodB();</span><br><span class=line>    ...</span><br><span class=line>  &#125;</span><br><span class=line> </span><br><span class=line>  @Async</span><br><span class=line>  public void methodB() &#123;</span><br><span class=line>    ...</span><br><span class=line>  &#125;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>完整示例：</p><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br></pre></td><td class=code><pre><span class=line></span><br><span class=line>package com.web.rest.controller;</span><br><span class=line> </span><br><span class=line>import org.aspectj.lang.annotation.Aspect;</span><br><span class=line>import org.slf4j.Logger;</span><br><span class=line>import org.slf4j.LoggerFactory;</span><br><span class=line>import org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line>import org.springframework.scheduling.annotation.Async;</span><br><span class=line>import org.springframework.web.bind.annotation.GetMapping;</span><br><span class=line>import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=line>import org.springframework.web.bind.annotation.RestController;</span><br><span class=line> </span><br><span class=line>import java.util.List;</span><br><span class=line> </span><br><span class=line>/**</span><br><span class=line> * @描 述: Manager类Controller接口类</span><br><span class=line> */</span><br><span class=line>@RestController</span><br><span class=line>@RequestMapping(&quot;manager&quot;)</span><br><span class=line>public class ManagerController &#123;</span><br><span class=line>    private final Logger logger = LoggerFactory.getLogger(ManagerController.class);</span><br><span class=line>    @Autowired</span><br><span class=line>    private ManagerRepository managerRepository;</span><br><span class=line>//    @Autowired</span><br><span class=line>//    private AsyncController asyncController;</span><br><span class=line> </span><br><span class=line>    /**</span><br><span class=line>     * @描述 查询所有的数据的异常测试类</span><br><span class=line>     * @参数  []</span><br><span class=line>     **/</span><br><span class=line>    @GetMapping(&quot;all&quot;)</span><br><span class=line>    public Result getAll()&#123;</span><br><span class=line>        ManagerController bean = SpringUtils.getBean(ManagerController.class);</span><br><span class=line>        logger.debug(&quot;查询所有的manager&quot;);</span><br><span class=line>        List&lt;ManagerEntity&gt; all = managerRepository.findAll();</span><br><span class=line>        bean.test();</span><br><span class=line>        bean.test();</span><br><span class=line>        return Result.error(&quot;数据请求服务未启用&quot;,&quot;type&quot;,&quot;subtype&quot;);</span><br><span class=line>    &#125;</span><br><span class=line> </span><br><span class=line> </span><br><span class=line>    @Async</span><br><span class=line>    public void test()&#123;</span><br><span class=line>        try &#123;</span><br><span class=line>            logger.debug(&quot;=======开始执行异步处理类========&quot;);</span><br><span class=line>            Thread.sleep(2000);</span><br><span class=line>        &#125;catch (Exception e)&#123;</span><br><span class=line>            e.printStackTrace();</span><br><span class=line>        &#125;</span><br><span class=line>    &#125;</span><br><span class=line> </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>SpringUtils的工具类，手动获取bean方法：</p><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br></pre></td><td class=code><pre><span class=line>package com.web.rest.util;</span><br><span class=line> </span><br><span class=line>import org.springframework.beans.BeansException;</span><br><span class=line>import org.springframework.context.ApplicationContext;</span><br><span class=line>import org.springframework.context.ApplicationContextAware;</span><br><span class=line>import org.springframework.stereotype.Component;</span><br><span class=line> </span><br><span class=line>/**</span><br><span class=line> * @描 述: 手动获取spring的bean</span><br><span class=line> */</span><br><span class=line>@Component(&quot;springContextUtil&quot;)</span><br><span class=line>public class SpringUtils implements ApplicationContextAware &#123;</span><br><span class=line> </span><br><span class=line> </span><br><span class=line>    private static ApplicationContext applicationContext = null;</span><br><span class=line> </span><br><span class=line>    public static ApplicationContext getApplicationContext() &#123;</span><br><span class=line>        return applicationContext;</span><br><span class=line>    &#125;</span><br><span class=line> </span><br><span class=line>    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class=line>    public static &lt;T&gt; T getBean(String beanId) &#123;</span><br><span class=line>        return (T) applicationContext.getBean(beanId);</span><br><span class=line>    &#125;</span><br><span class=line> </span><br><span class=line>    public static &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) &#123;</span><br><span class=line>        return (T) applicationContext.getBean(requiredType);</span><br><span class=line>    &#125;</span><br><span class=line>    /**</span><br><span class=line>     * Spring容器启动后，会把 applicationContext 给自动注入进来，然后我们把 applicationContext</span><br><span class=line>     *  赋值到静态变量中，方便后续拿到容器对象</span><br><span class=line>     * @see org.springframework.context.ApplicationContextAware#setApplicationContext(org.springframework.context.ApplicationContext)</span><br><span class=line>     */</span><br><span class=line>    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class=line>        SpringUtils.applicationContext = applicationContext;</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h4 id=补充><a href=#补充 class=headerlink title=补充></a>补充</h4><p>Transactional失效情况<br>@Transactional 加于private方法, 无效<br>@Transactional 加于未加入接口的public方法, 再通过普通接口方法调用, 无效<br>@Transactional 加于接口方法, 无论下面调用的是private或public方法, 都有效<br>@Transactional 加于接口方法后, 被本类普通接口方法直接调用, 无效<br>@Transactional 加于接口方法后, 被本类普通接口方法通过接口调用, 有效<br>@Transactional 加于接口方法后, 被它类的接口方法调用, 有效<br>@Transactional 加于接口方法后, 被它类的私有方法调用后, 有效</p></div><div class=post-copyright><div class=post-copyright-icon></div><div class=post-copyright-author><span class=post-copyright-meta>文章作者: </span><span class=post-copyright-info><a href=mailto:junjieliao@139.com>ljj</a></span></div><div class=post-copyright-type><span class=post-copyright-meta>文章链接: </span><span class=post-copyright-info><a href=https://example.com/2022/04/07/springboot异步调用@Async注解/ >https://example.com/2022/04/07/springboot异步调用@Async注解/</a></span></div><div class=post-copyright-notice><span class=post-copyright-meta>版权声明: </span><span class=post-copyright-info>本博客所有文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0 </a>许可协议。转载请注明来自 <a href=https://example.com/2022/04/07/springboot异步调用@Async注解/ target=_blank>Hexo-Theme-MengD(萌典)</a> ！</span></div></div><div class=pagination-post><a href=/2022/04/12/%E4%BA%8B%E5%8A%A1/ ><div class=prev-title><i class="fas fa-chevron-left"></i>事务</div><div class=prev-desc></div></a><a href=/2022/03/26/test/ ><div class=next-title>test<i class="fas fa-chevron-right"></i></div><div class=next-desc>hexo图片使用示例</div></a></div></article><div id=toc-wrap><div id=toc><div class=toc-title><div>目录 <span class=num>0%</span></div><progress class=progress value=0 max=100></progress></div><div class=toc-list><ol class=toc><li class="toc-item toc-level-2"><a class=toc-link href=#%E8%83%8C%E6%99%AF><span class=toc-text>背景</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E9%85%8D%E7%BD%AE><span class=toc-text>配置</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E9%94%99%E8%AF%AF%E7%A4%BA%E8%8C%83><span class=toc-text>错误示范</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E6%AD%A3%E7%A1%AE%E5%81%9A%E6%B3%95><span class=toc-text>正确做法</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#%E7%A9%B6%E5%85%B6%E5%8E%9F%E5%9B%A0><span class=toc-text>究其原因:</span></a><ol class=toc-child><li class="toc-item toc-level-5"><a class=toc-link href=#%E4%B8%80%E8%88%AC%E5%AF%BC%E8%87%B4-Async%E5%A4%B1%E6%95%88%E5%8E%9F%E5%9B%A0><span class=toc-text>一般导致@Async失效原因</span></a></li></ol></li></ol></li></ol><li class="toc-item toc-level-2"><a class=toc-link href=#%E5%8D%87%E5%8D%8E><span class=toc-text>升华</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#%E5%A6%82%E4%BD%95%E5%9C%A8%E6%9C%AC%E7%B1%BB%E4%B8%AD%E8%B0%83%E7%94%A8><span class=toc-text>如何在本类中调用</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E8%A1%A5%E5%85%85><span class=toc-text>补充</span></a></li></ol></li></div></div></div></main><section id=rightside><div class=rightside-item><a id=open-toc title=目录><i class="fas fa-list-ul"></i> </a><a href=javascript:(0) id=darkmode title="深色/浅色 "><i class="fas fa-moon"></i> </a><a href=# title=回到顶部><i class="fas fa-arrow-up"></i></a></div></section><footer class=footer id=footer><div class=copyright>&copy; 2020 - 2022 <i class="fas fa-fan"></i> ljj</div><div class=framework-info><span>框架 </span><a href=https://hexo.io target=_blank>Hexo</a> <span class=footer-separator>|</span> <span>主题 </span><a href=https://github.com/lete114/hexo-theme-MengD target=_blank>MengD.(萌典)</a></div><div class=custom-text>我相信我可以，一直在路上，有无限的可能！！</div></footer></div><div id=mask onclick=closeAll()></div><div id=local-search><div id=local-search-title>本地搜索</div><input id=local-search-input autocomplete=off placeholder=搜索文章 type=text><hr><div id=local-search-result></div><span class=search-close-button><i class="fas fa-times"></i></span></div><script src=/js/search.js></script><div class=script><script src=/js/main.js></script><script>var titleTime,originTitle=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="(つェ⊂) 我藏好了哦~ "+originTitle,clearTimeout(titleTime)):(document.title="(*´∇｀*) 被你发现啦~ "+originTitle,titleTime=setTimeout(function(){document.title=originTitle},2e3))})</script><script src=/js/lazyload.js></script><script>function LoadPjax(){window.pjax=new Pjax({selectors:["head title",'head meta[name="keywords"]','head meta[name="description"]',"main","#rightside"],cacheBust:!1})}getScript("https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js",LoadPjax);var timer=null;function ProgressStart(){var t=10,e=document.createElement("div");e.className="pjax-progress",document.body.prepend(e);clearInterval(timer),timer=setInterval(function(){var e=parseInt(7*Math.random());t+=e+3,document.getElementsByClassName("pjax-progress")[0].style.width=t+"%",95<t&&(t=95)},500)}function ProgressFinish(){clearInterval(timer);var e=document.getElementsByClassName("pjax-progress");e[0].style.width="100%",timer=setTimeout(function(){e[0].parentNode.removeChild(e[0])},700)}document.addEventListener("pjax:send",function(){ProgressStart()}),document.addEventListener("pjax:complete",function(){ProgressFinish(),exeAllFn(),ImgLazyLoad("body img[data-img]","data-img"),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script");var a=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(a)),e.parentNode.replaceChild(t,e)})}),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script></div></body></html>