{"meta":{"title":"FreeTime","subtitle":"","description":"","author":"ljj","url":"https://example.com","root":"/"},"pages":[{"title":"categories","date":"2022-03-22T04:47:34.000Z","updated":"2022-03-22T04:47:34.846Z","comments":true,"path":"categories/index.html","permalink":"https://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"索引","slug":"索引","date":"2022-04-12T14:18:18.000Z","updated":"2022-04-12T15:49:03.158Z","comments":true,"path":"2022/04/12/索引/","link":"","permalink":"https://example.com/2022/04/12/%E7%B4%A2%E5%BC%95/","excerpt":"","text":"1.两种基本的索引类型顺序索引和散列索引： 顺序索引 （基于值的顺序排序） 聚集索引 （记录的物理排列顺序和索引一致） 非聚集索引（记录的物理排列顺序和索引不一致）聚集和非聚集的区别在于记录的排列顺序和索引的排列顺序是否一致，因此一个表只能包含一个聚集索引。 稠密索引 （文件中的每一个搜索码值都有一个索引记录） 稀疏索引 （只为搜索码的某些值建立索引）非聚集索引必须是稠密索引，而聚集索引可以是稀疏索引，因为聚集索引的排列顺序和记录排列顺序一致，可以沿索引项指向的记录开始，沿文件中的指针查找，知道找到所需记录。 多级索引 散列索引 （基于值平均分布到若干散列桶中） 2.B+树结构更新中…","categories":[{"name":"数据库","slug":"数据库","permalink":"https://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"事务","slug":"事务","date":"2022-04-12T14:17:59.000Z","updated":"2022-04-12T14:20:22.797Z","comments":true,"path":"2022/04/12/事务/","link":"","permalink":"https://example.com/2022/04/12/%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"","categories":[{"name":"数据库","slug":"数据库","permalink":"https://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"springboot异步调用@Async注解","slug":"springboot异步调用@Async注解","date":"2022-04-06T16:13:43.000Z","updated":"2022-04-09T05:26:41.808Z","comments":true,"path":"2022/04/07/springboot异步调用@Async注解/","link":"","permalink":"https://example.com/2022/04/07/springboot%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8@Async%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"背景当访问其他人的接口较慢或者做耗时任务时，不想程序一直卡在耗时任务上，想程序能够并行执行，我们可以使用多线程来并行的处理任务，也可以使用spring提供的异步处理方式@Async。 配置启动类增加EnableAsync注解 123456789...@EnableAsync...public class SingleApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SingleApplication.class, args); &#125;... 错误示范同类方法中使用异步注解没有作用,这样执行后就,是串行单线程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.web.rest.controller; import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.scheduling.annotation.Async;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController; /** * 描述: 测试异步调用; * 测试多线程调用 * */@RestController@RequestMapping(&quot;/&quot;)public class AsyncController &#123; private final Logger log = LoggerFactory.getLogger(this.getClass()); @Autowired private AsyncControllerTest asyncControllerTest; /** * @Description //方法调用接口类 * @param * @return java.lang.String **/ @GetMapping(&quot;test&quot;) public String test()&#123;// asyncControllerTest.doAsyncMethod();// asyncControllerTest.doAsyncMethod(); doAsyncMethod(); doAsyncMethod(); log.debug(&quot;主线程执行结束......&quot;); return &quot;SUCCESS&quot;; &#125; /** * @Description //同类方法中的异步标签 * @param * @return void **/ @Async private void doAsyncMethod() &#123; try &#123; //todo Thread.sleep(2000); log.debug(&quot;异步方法执行了......&quot;); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; 正确做法改正使用调用另外的类,然后通过注入的方式注入对象: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.web.rest.controller; import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.scheduling.annotation.Async;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController; /** * 描述: 测试异步调用; * 测试多线程调用 * */@RestController@RequestMapping(&quot;/&quot;)public class AsyncController &#123; private final Logger log = LoggerFactory.getLogger(this.getClass()); @Autowired private AsyncControllerTest asyncControllerTest; /** * @Description //方法调用接口类 * @param * @return java.lang.String **/ @GetMapping(&quot;test&quot;) public String test()&#123; asyncControllerTest.doAsyncMethod(); asyncControllerTest.doAsyncMethod();// doAsyncMethod();// doAsyncMethod(); log.debug(&quot;主线程执行结束......&quot;); return &quot;SUCCESS&quot;; &#125; /** * @Author Young * @Description //同类方法中的异步标签 * @Date 16:45 2019/3/11 * @param * @return void **/ @Async private void doAsyncMethod() &#123; try &#123; //todo Thread.sleep(2000); log.debug(&quot;异步方法执行了......&quot;); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; 12345678910111213141516171819202122232425262728package com.web.rest.controller; import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.scheduling.annotation.Async;import org.springframework.stereotype.Component; /** * 描述:异步类 * */@Componentpublic class AsyncControllerTest &#123; private final Logger log = LoggerFactory.getLogger(this.getClass()); @Async public void doAsyncMethod() &#123; try &#123; //todo Thread.sleep(2000); log.debug(&quot;异步方法执行了......&quot;); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 究其原因:简单说就是没有过去到代理类,本类调用时,直接自己内部调用,没有走代理类 一般导致@Async失效原因1.没有在@SpringBootApplication启动类当中添加注解@EnableAsync注解。2.异步方法使用注解@Async的返回值只能为void或者Future。3.没有走Spring的代理类。因为@Transactional和@Async注解的实现都是基于Spring的AOP，而AOP的实现是基于动态代理模式实现的。那么注解失效的原因就很明显了，有可能因为调用方法的是对象本身而不是代理对象，因为没有经过Spring容器。 升华如何在本类中调用这里具体说一下 (导致@Async失效原因) 第三种情况的解决方法。1.注解的方法必须是public方法。2.方法一定要从另一个类中调用，也就是从类的外部调用，类的内部调用是无效的。3.如果需要从类的内部调用，需要先获取其代理类，下面上代码 123456789101112131415@Servicepublic class XxxService&#123; public void methodA()&#123; ... XxxService xxxServiceProxy = SpringUtil.getBean(XxxService.class); xxxServiceProxy.methodB(); ... &#125; @Async public void methodB() &#123; ... &#125;&#125; 完整示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.web.rest.controller; import org.aspectj.lang.annotation.Aspect;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.scheduling.annotation.Async;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController; import java.util.List; /** * @描 述: Manager类Controller接口类 */@RestController@RequestMapping(&quot;manager&quot;)public class ManagerController &#123; private final Logger logger = LoggerFactory.getLogger(ManagerController.class); @Autowired private ManagerRepository managerRepository;// @Autowired// private AsyncController asyncController; /** * @描述 查询所有的数据的异常测试类 * @参数 [] **/ @GetMapping(&quot;all&quot;) public Result getAll()&#123; ManagerController bean = SpringUtils.getBean(ManagerController.class); logger.debug(&quot;查询所有的manager&quot;); List&lt;ManagerEntity&gt; all = managerRepository.findAll(); bean.test(); bean.test(); return Result.error(&quot;数据请求服务未启用&quot;,&quot;type&quot;,&quot;subtype&quot;); &#125; @Async public void test()&#123; try &#123; logger.debug(&quot;=======开始执行异步处理类========&quot;); Thread.sleep(2000); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; SpringUtils的工具类，手动获取bean方法： 12345678910111213141516171819202122232425262728293031323334353637package com.web.rest.util; import org.springframework.beans.BeansException;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.stereotype.Component; /** * @描 述: 手动获取spring的bean */@Component(&quot;springContextUtil&quot;)public class SpringUtils implements ApplicationContextAware &#123; private static ApplicationContext applicationContext = null; public static ApplicationContext getApplicationContext() &#123; return applicationContext; &#125; @SuppressWarnings(&quot;unchecked&quot;) public static &lt;T&gt; T getBean(String beanId) &#123; return (T) applicationContext.getBean(beanId); &#125; public static &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) &#123; return (T) applicationContext.getBean(requiredType); &#125; /** * Spring容器启动后，会把 applicationContext 给自动注入进来，然后我们把 applicationContext * 赋值到静态变量中，方便后续拿到容器对象 * @see org.springframework.context.ApplicationContextAware#setApplicationContext(org.springframework.context.ApplicationContext) */ public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; SpringUtils.applicationContext = applicationContext; &#125;&#125; 补充Transactional失效情况@Transactional 加于private方法, 无效@Transactional 加于未加入接口的public方法, 再通过普通接口方法调用, 无效@Transactional 加于接口方法, 无论下面调用的是private或public方法, 都有效@Transactional 加于接口方法后, 被本类普通接口方法直接调用, 无效@Transactional 加于接口方法后, 被本类普通接口方法通过接口调用, 有效@Transactional 加于接口方法后, 被它类的接口方法调用, 有效@Transactional 加于接口方法后, 被它类的私有方法调用后, 有效","categories":[{"name":"spring","slug":"spring","permalink":"https://example.com/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://example.com/tags/spring/"}]},{"title":"test","slug":"test","date":"2022-03-25T16:17:20.000Z","updated":"2022-04-09T05:22:59.162Z","comments":true,"path":"2022/03/26/test/","link":"","permalink":"https://example.com/2022/03/26/test/","excerpt":"","text":"hexo图片使用示例","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://example.com/tags/hexo/"}]},{"title":"基于接口SchedulingConfigurer的动态定时任务","slug":"基于接口SchedulingConfigurer的动态定时任务","date":"2022-03-25T02:33:01.000Z","updated":"2022-04-09T05:26:05.016Z","comments":true,"path":"2022/03/25/基于接口SchedulingConfigurer的动态定时任务/","link":"","permalink":"https://example.com/2022/03/25/%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3SchedulingConfigurer%E7%9A%84%E5%8A%A8%E6%80%81%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","excerpt":"","text":"一般配置都是基于注解(@Scheduled)的简单定时器，其使用固定的cron表达式，现在想使用动态方式配置任务周期。 1. 固定的简单定时器如下配置： 12345678910111213141516171819202122232425262728293031323334353637package com.example.schedule.SimpleSchedule;import org.springframework.scheduling.annotation.Scheduled;import java.time.LocalDateTime;/** * @fileName：Schedule * @createTime：2019/5/14 17:16 * @author： * @version： * @description：基于注解(@Scheduled)的简单定时器demo * * cron表达式语法:[秒] [分] [小时] [日] [月] [周] [年] * @Scheduled(fixedDelay = 5000) //上一次执行完毕时间点之后5秒再执行 * @Scheduled(fixedDelayString = &quot;5000&quot;) //上一次执行完毕时间点之后5秒再执行 * @Scheduled(fixedRate = 5000) //上一次开始执行时间点之后5秒再执行 * @Scheduled(initialDelay=1000, fixedRate=5000) //第一次延迟1秒后执行，之后按fixedRate的规则每5秒执行一次 * *///1.主要用于标记配置类@Configuration// 2.开启定时任务@EnableSchedulingpublic class Schedule &#123; //3.添加定时任务 @Scheduled(cron = &quot;0/5 * * * * ?&quot;) //或直接指定时间间隔，例如：5秒 //@Scheduled(fixedRate=5000) private void configureTasks() &#123; System.err.println(&quot;基于注解(@Scheduled)的简单定时器demo: &quot; + LocalDateTime.now()); &#125;&#125; 2. 基于接口SchedulingConfigurer的动态定时任务此种方法实现SchedulingConfigurer 类，采用多线程方式跑定时任务 12345678910111213141516171819202122232425262728293031323334353637383940/** * @author ljj */@Component@EnableScheduling@Slf4jpublic class ResourceBackupTask implements SchedulingConfigurer &#123; @Autowired private ProjectService projectService; @Value(&quot;$&#123;egova.wukong.project.backup.enabled:true&#125;&quot;) private boolean projectBackupEnable; @Value(&quot;$&#123;egova.wukong.project.backup.cron:0 0 2 * * ? &#125;&quot;) private String projectBackupCron; @Override public void configureTasks(ScheduledTaskRegistrar scheduledTaskRegistrar) &#123; //增加任务 addTriggerTask可继续添加任务 scheduledTaskRegistrar.addTriggerTask(this::projectBackupTask, triggerContext -&gt; &#123; CronTrigger cronTrigger = new CronTrigger(projectBackupCron); return cronTrigger.nextExecutionTime(triggerContext); &#125;); &#125; /** * 项目备份逻辑 */ void projectBackupTask() &#123; if (!projectBackupEnable) &#123; return; &#125; log.info(&quot;开始项目备份任务, cron配置为：&#123;&#125;&quot;, projectBackupCron); int size = projectService.projectBackupTask(); log.info(&quot;项目备份任务结束，完成 &#123;&#125;个项目的备份&quot;, size); &#125;&#125;","categories":[{"name":"spring","slug":"spring","permalink":"https://example.com/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://example.com/tags/spring/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-03-25T01:43:15.251Z","updated":"2022-03-25T16:06:38.242Z","comments":true,"path":"2022/03/25/hello-world/","link":"","permalink":"https://example.com/2022/03/25/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo使用","slug":"hexo使用","permalink":"https://example.com/categories/hexo%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://example.com/tags/hexo/"}]},{"title":"一次线上OOM问题排查","slug":"一次线上OOM问题排查","date":"2022-03-22T16:37:48.000Z","updated":"2022-04-10T06:52:25.646Z","comments":true,"path":"2022/03/23/一次线上OOM问题排查/","link":"","permalink":"https://example.com/2022/03/23/%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8AOOM%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/","excerpt":"未完参考文章 https://www.jianshu.com/p/1b776d6af597","text":"未完参考文章 https://www.jianshu.com/p/1b776d6af597 jdk8 的内存模型–","categories":[{"name":"运维","slug":"运维","permalink":"https://example.com/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://example.com/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"hexo新建文章分类","slug":"hexo新建文章分类","date":"2022-03-22T04:46:07.000Z","updated":"2022-03-25T16:05:29.474Z","comments":true,"path":"2022/03/22/hexo新建文章分类/","link":"","permalink":"https://example.com/2022/03/22/hexo%E6%96%B0%E5%BB%BA%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB/","excerpt":"如何创建分类","text":"如何创建分类 1.创建分类选项博客目录下执行 1hexo new page categories 成功后提示 1INFO Created: E:\\blog\\junjieliao593.github.io\\source\\categories\\index.md 可以看到生成的文件 1234---title: categoriesdate: 2022-03-22 12:47:34--- 添加type: “categories”到内容中，添加后是这样的： 12345---title: 文章分类date: 2017-05-27 13:47:40type: &quot;categories&quot;--- 至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了categories: xxx的文章才会被收录到首页的“分类”中。 2.给文章添加分类添加tags和分类实例： 1234567---title: hexo新建文章分类date: 2022-03-22 12:46:07tags: hexotoc: truecategories: hexo使用---","categories":[{"name":"hexo使用","slug":"hexo使用","permalink":"https://example.com/categories/hexo%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://example.com/tags/hexo/"}]},{"title":"使用Java8中的parallelStream的一次问题记录","slug":"使用Java8中的parallelStream的问题","date":"2022-03-21T16:27:51.000Z","updated":"2022-04-10T06:52:26.738Z","comments":true,"path":"2022/03/22/使用Java8中的parallelStream的问题/","link":"","permalink":"https://example.com/2022/03/22/%E4%BD%BF%E7%94%A8Java8%E4%B8%AD%E7%9A%84parallelStream%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"在 java8 中 添加了流Stream，可以让你以一种声明的方式处理数据。使用起来非常简单优雅。ParallelStream 则是一个并行执行的流，采用 ForkJoinPool 并行执行任务，提高执行速度。","text":"在 java8 中 添加了流Stream，可以让你以一种声明的方式处理数据。使用起来非常简单优雅。ParallelStream 则是一个并行执行的流，采用 ForkJoinPool 并行执行任务，提高执行速度。 1. 现象压测出现报错 12345678910111213141516171819202122232425262728293031323334353637383940414243444546472022-03-19 16:32:08Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.211-b12 mixed mode):&quot;Attach Listener&quot; #147 daemon prio=9 os_prio=0 tid=0x00007fd14c001000 nid=0x708f runnable [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;ForkJoinPool.commonPool-worker-1&quot; #146 daemon prio=5 os_prio=0 tid=0x00007fd0c0057800 nid=0x6370 waiting for monitor entry [0x00007fd0725ea000] java.lang.Thread.State: BLOCKED (on object monitor) at java.util.stream.FindOps$FindTask.makeChild(FindOps.java:268) at java.util.stream.FindOps$FindTask.makeChild(FindOps.java:249) at java.util.stream.AbstractShortCircuitTask.compute(AbstractShortCircuitTask.java:120) at java.util.concurrent.CountedCompleter.exec(CountedCompleter.java:731) at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289) at java.util.concurrent.ForkJoinPool.helpComplete(ForkJoinPool.java:1870) at java.util.concurrent.ForkJoinPool.awaitJoin(ForkJoinPool.java:2045) at java.util.concurrent.ForkJoinTask.doInvoke(ForkJoinTask.java:404) at java.util.concurrent.ForkJoinTask.invoke(ForkJoinTask.java:734) at java.util.stream.FindOps$FindOp.evaluateParallel(FindOps.java:159) at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:233) at java.util.stream.ReferencePipeline.findAny(ReferencePipeline.java:469) at com.egova.wukong.service.impl.PageServiceImpl.lambda$getPageCards$22(PageServiceImpl.java:571) at com.egova.wukong.service.impl.PageServiceImpl$$Lambda$1107/1403252310.apply(Unknown Source) at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) at java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948) at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) at java.util.stream.ReduceOps$ReduceTask.doLeaf(ReduceOps.java:747) at java.util.stream.ReduceOps$ReduceTask.doLeaf(ReduceOps.java:721) at java.util.stream.AbstractTask.compute(AbstractTask.java:316) at java.util.concurrent.CountedCompleter.exec(CountedCompleter.java:731) at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289) at java.util.concurrent.ForkJoinPool$WorkQueue.execLocalTasks(ForkJoinPool.java:1040) at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1058) at java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692) at java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)&quot;ForkJoinPool.commonPool-worker-7&quot; #145 daemon prio=5 os_prio=0 tid=0x00007fd0880ba000 nid=0x632f waiting for monitor entry [0x00007fd0720e5000] java.lang.Thread.State: BLOCKED (on object monitor) at java.util.stream.FindOps$FindTask.makeChild(FindOps.java:268) at java.util.stream.FindOps$FindTask.makeChild(FindOps.java:249) at java.util.stream.AbstractShortCircuitTask.compute(AbstractShortCircuitTask.java:119) at java.util.concurrent.CountedCompleter.exec(CountedCompleter.java:731) at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289) at java.util.concurrent.ForkJoinPool.helpComplete(ForkJoinPool.java:1870) at java.util.concurrent.ForkJoinPool.awaitJoin(ForkJoinPool.java:2045) at java.util.concurrent.ForkJoinTask.doInvoke(ForkJoinTask.java:404) at java.util.concurrent.ForkJoinTask.invoke(ForkJoinTask.java:734) 错误日志指向ForkJoinTask，线程发生阻塞。项目代码 12345678910111213141516171819 .....List&lt;CardData&gt; finalCardDataList = cardDataList;return pageCards.parallelStream() //第一次并行流 .sorted(Comparator.comparingInt(PageCard::getLevel).reversed()) .map(pageCard -&gt; &#123; PageCardModel pageCardModel = new PageCardModel(); pageCardModel.setBase(cards.parallelStream() //第二次并行流 .filter(card -&gt; StringUtils.equals(card.getId(), pageCard.getCardId())).findAny().orElse(null)); pageCardModel.setData(finalCardDataList.parallelStream() //第三次并行流 .filter(cardData -&gt; StringUtils.equals(cardData.getId(), pageCard.getDataId())).findAny().orElse(null)); pageCardModel.setStyle(pageCard.getStyle()); pageCardModel.setId(pageCard.getId()); pageCardModel.setName(pageCard.getName()); return pageCardModel; &#125;).collect(Collectors.toList());&#125;parallelStream流内，嵌套两层，并返回大json数据，导致线程占满，IO阻塞 2. 初步推测并行流陷阱 线程安全 由于并行流使用多线程，则一切线程安全问题都应该是需要考虑的问题，如：资源竞争、死锁、事务、可见性等等 线程消费 在虚拟机启动时，我们指定了worker线程的数量，整个程序的生命周期都将使用这些工作线程；这必然存在任务生产和消费的问题，如果某个生产者生产了许多重量级的任务（耗时很长），那么其他任务毫无疑问将会没有工作线程可用；更可怕的事情是这些工作线程正在进行IO阻塞。 3.设置并行参数我们可以通过虚拟机启动参数，控制ForkJoinPool的线程数-Djava.util.concurrent.ForkJoinPool.common.parallelism&#x3D;N 来设置worker的数量。 4. 扩展parallelStreams()，使用ForkJoinPool。资源耗尽时使用线程池的默认拒绝策略，在默认的ThreadPoolExecutor.AbortPolicy中，处理程序抛出一个拒绝后运行时RejectedExecutionException。 4. 小结串行流：适合存在线程安全问题、阻塞任务、重量级任务，以及需要使用同一事务的逻辑。 并行流：适合没有线程安全问题、较单纯的数据处理任务。","categories":[{"name":"spring","slug":"spring","permalink":"https://example.com/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://example.com/tags/spring/"}]},{"title":"windows下搭建hexo博客","slug":"win10下搭建hexo博客","date":"2022-03-18T14:53:55.000Z","updated":"2022-03-25T16:06:54.775Z","comments":true,"path":"2022/03/18/win10下搭建hexo博客/","link":"","permalink":"https://example.com/2022/03/18/win10%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/","excerpt":"[TOC]","text":"[TOC] 1.安装nodejs略 2.切换淘宝源(有梯子则不切换)：npm install -g cnpm –registry &#x3D;https://registry.npm.taobao.org 3.安装hexo:cnpm install -g hexo-cli 4.使用hexo搭建。 新建blog文件夹 初始化sudo hexo init或 hexo init windows管理员权限出现问题。hexo : 无法加载文件 C:\\Users\\xxx\\AppData\\Roaming\\npm\\hexo.ps1，因为在此系统上禁止运行脚本。 解决方案在默认情况下，我们是无法执行powershell脚本的， 需要更改执行策略。win10下更改执行策略：1.打开设置 2.搜索power 选择选项：允许本地powershell在不签名的情况下运行3.勾选，点击应用就可以了 5.启动hexo s 6.github新建仓库。仓库名必须是 用户名.github.io 例如junjieliao593新建的仓库名为：junjieliao593.github.io.git 7.本地下载git插件 cnpm install –save hexo-deployer-git 8.设置blog目录下__cofig.yml配置。 Deloyment配置git仓库地址及分支 deploy:type: gitrepo: https://github.com/junjieliao593/junjieliao593.github.iobranch: master 9.部署发布hexo d 10.访问junjieliao593.github.io 11.主题https://github.com/litten/hexo-theme-yilia git clone https://github.com/litten/hexo-theme-yilia.git themes&#x2F;yilia 修改blog目录下_config.yml配置： theme: yilia 清理hexo clean 重构hexo g 预览hexo s 推到远程仓库hexo d 其他主题https://github.com/theme-next/hexo-theme-next 12.编辑文章md文件存放在 blog\\source_posts目录下，用其他编辑器操作即可。 13. 后续可参考文档官方文档： https://hexo.io/zh-cn/docs/完成操作文档(包含多终端工作指南)： https://blog.csdn.net/sinat_37781304/article/details/82729029 补充推荐一个很好看的主题，也是当前本人博客所用的主题，有比较详细的中文文档，https://mengd.js.org/","categories":[{"name":"hexo使用","slug":"hexo使用","permalink":"https://example.com/categories/hexo%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://example.com/tags/hexo/"}]}],"categories":[{"name":"数据库","slug":"数据库","permalink":"https://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"spring","slug":"spring","permalink":"https://example.com/categories/spring/"},{"name":"hexo使用","slug":"hexo使用","permalink":"https://example.com/categories/hexo%E4%BD%BF%E7%94%A8/"},{"name":"运维","slug":"运维","permalink":"https://example.com/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"spring","slug":"spring","permalink":"https://example.com/tags/spring/"},{"name":"hexo","slug":"hexo","permalink":"https://example.com/tags/hexo/"},{"name":"运维","slug":"运维","permalink":"https://example.com/tags/%E8%BF%90%E7%BB%B4/"}]}