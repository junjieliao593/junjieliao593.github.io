{"meta":{"title":"FreeTime","subtitle":"","description":"","author":"ljj","url":"https://example.com","root":"/"},"pages":[{"title":"categories","date":"2022-03-22T04:47:34.000Z","updated":"2022-03-22T04:47:34.846Z","comments":true,"path":"categories/index.html","permalink":"https://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"test","slug":"test","date":"2022-03-25T16:17:20.000Z","updated":"2022-03-25T16:32:27.326Z","comments":true,"path":"2022/03/26/test/","link":"","permalink":"https://example.com/2022/03/26/test/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"java异步调用","slug":"java异步调用","date":"2022-03-25T03:18:43.000Z","updated":"2022-03-25T03:19:06.740Z","comments":true,"path":"2022/03/25/java异步调用/","link":"","permalink":"https://example.com/2022/03/25/java%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/","excerpt":"","text":"未完成参考 https://segmentfault.com/a/1190000010142962?utm_source=sf-similar-article","categories":[],"tags":[]},{"title":"基于接口SchedulingConfigurer的动态定时任务","slug":"基于接口SchedulingConfigurer的动态定时任务","date":"2022-03-25T02:33:01.000Z","updated":"2022-03-25T15:23:05.633Z","comments":true,"path":"2022/03/25/基于接口SchedulingConfigurer的动态定时任务/","link":"","permalink":"https://example.com/2022/03/25/%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3SchedulingConfigurer%E7%9A%84%E5%8A%A8%E6%80%81%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","excerpt":"","text":"一般配置都是基于注解(@Scheduled)的简单定时器，其使用固定的cron表达式，现在想使用动态方式配置任务周期。 1. 固定的简单定时器如下配置： 12345678910111213141516171819202122232425262728293031323334353637package com.example.schedule.SimpleSchedule;import org.springframework.scheduling.annotation.Scheduled;import java.time.LocalDateTime;/** * @fileName：Schedule * @createTime：2019/5/14 17:16 * @author： * @version： * @description：基于注解(@Scheduled)的简单定时器demo * * cron表达式语法:[秒] [分] [小时] [日] [月] [周] [年] * @Scheduled(fixedDelay = 5000) //上一次执行完毕时间点之后5秒再执行 * @Scheduled(fixedDelayString = &quot;5000&quot;) //上一次执行完毕时间点之后5秒再执行 * @Scheduled(fixedRate = 5000) //上一次开始执行时间点之后5秒再执行 * @Scheduled(initialDelay=1000, fixedRate=5000) //第一次延迟1秒后执行，之后按fixedRate的规则每5秒执行一次 * *///1.主要用于标记配置类@Configuration// 2.开启定时任务@EnableSchedulingpublic class Schedule &#123; //3.添加定时任务 @Scheduled(cron = &quot;0/5 * * * * ?&quot;) //或直接指定时间间隔，例如：5秒 //@Scheduled(fixedRate=5000) private void configureTasks() &#123; System.err.println(&quot;基于注解(@Scheduled)的简单定时器demo: &quot; + LocalDateTime.now()); &#125;&#125; 2. 基于接口SchedulingConfigurer的动态定时任务此种方法实现SchedulingConfigurer 类，采用多线程方式跑定时任务 12345678910111213141516171819202122232425262728293031323334353637383940/** * @author ljj */@Component@EnableScheduling@Slf4jpublic class ResourceBackupTask implements SchedulingConfigurer &#123; @Autowired private ProjectService projectService; @Value(&quot;$&#123;egova.wukong.project.backup.enabled:true&#125;&quot;) private boolean projectBackupEnable; @Value(&quot;$&#123;egova.wukong.project.backup.cron:0 0 2 * * ? &#125;&quot;) private String projectBackupCron; @Override public void configureTasks(ScheduledTaskRegistrar scheduledTaskRegistrar) &#123; //增加任务 addTriggerTask可继续添加任务 scheduledTaskRegistrar.addTriggerTask(this::projectBackupTask, triggerContext -&gt; &#123; CronTrigger cronTrigger = new CronTrigger(projectBackupCron); return cronTrigger.nextExecutionTime(triggerContext); &#125;); &#125; /** * 项目备份逻辑 */ void projectBackupTask() &#123; if (!projectBackupEnable) &#123; return; &#125; log.info(&quot;开始项目备份任务, cron配置为：&#123;&#125;&quot;, projectBackupCron); int size = projectService.projectBackupTask(); log.info(&quot;项目备份任务结束，完成 &#123;&#125;个项目的备份&quot;, size); &#125;&#125;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-03-25T01:43:15.251Z","updated":"2022-03-25T16:06:38.242Z","comments":true,"path":"2022/03/25/hello-world/","link":"","permalink":"https://example.com/2022/03/25/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo使用","slug":"hexo使用","permalink":"https://example.com/categories/hexo%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://example.com/tags/hexo/"}]},{"title":"一次线上OOM问题排查","slug":"一次线上OOM问题排查","date":"2022-03-22T16:37:48.000Z","updated":"2022-03-25T01:43:15.253Z","comments":true,"path":"2022/03/23/一次线上OOM问题排查/","link":"","permalink":"https://example.com/2022/03/23/%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8AOOM%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/","excerpt":"未完参考文章 https://www.jianshu.com/p/1b776d6af597","text":"未完参考文章 https://www.jianshu.com/p/1b776d6af597","categories":[],"tags":[]},{"title":"hexo新建文章分类","slug":"hexo新建文章分类","date":"2022-03-22T04:46:07.000Z","updated":"2022-03-25T16:05:29.474Z","comments":true,"path":"2022/03/22/hexo新建文章分类/","link":"","permalink":"https://example.com/2022/03/22/hexo%E6%96%B0%E5%BB%BA%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB/","excerpt":"如何创建分类","text":"如何创建分类 1.创建分类选项博客目录下执行 1hexo new page categories 成功后提示 1INFO Created: E:\\blog\\junjieliao593.github.io\\source\\categories\\index.md 可以看到生成的文件 1234---title: categoriesdate: 2022-03-22 12:47:34--- 添加type: “categories”到内容中，添加后是这样的： 12345---title: 文章分类date: 2017-05-27 13:47:40type: &quot;categories&quot;--- 至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了categories: xxx的文章才会被收录到首页的“分类”中。 2.给文章添加分类添加tags和分类实例： 1234567---title: hexo新建文章分类date: 2022-03-22 12:46:07tags: hexotoc: truecategories: hexo使用---","categories":[{"name":"hexo使用","slug":"hexo使用","permalink":"https://example.com/categories/hexo%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://example.com/tags/hexo/"}]},{"title":"使用Java8中的parallelStream的一次问题记录","slug":"使用Java8中的parallelStream的问题","date":"2022-03-21T16:27:51.000Z","updated":"2022-03-25T15:22:46.864Z","comments":true,"path":"2022/03/22/使用Java8中的parallelStream的问题/","link":"","permalink":"https://example.com/2022/03/22/%E4%BD%BF%E7%94%A8Java8%E4%B8%AD%E7%9A%84parallelStream%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"在 java8 中 添加了流Stream，可以让你以一种声明的方式处理数据。使用起来非常简单优雅。ParallelStream 则是一个并行执行的流，采用 ForkJoinPool 并行执行任务，提高执行速度。","text":"在 java8 中 添加了流Stream，可以让你以一种声明的方式处理数据。使用起来非常简单优雅。ParallelStream 则是一个并行执行的流，采用 ForkJoinPool 并行执行任务，提高执行速度。 1. 现象压测出现报错 12345678910111213141516171819202122232425262728293031323334353637383940414243444546472022-03-19 16:32:08Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.211-b12 mixed mode):&quot;Attach Listener&quot; #147 daemon prio=9 os_prio=0 tid=0x00007fd14c001000 nid=0x708f runnable [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;ForkJoinPool.commonPool-worker-1&quot; #146 daemon prio=5 os_prio=0 tid=0x00007fd0c0057800 nid=0x6370 waiting for monitor entry [0x00007fd0725ea000] java.lang.Thread.State: BLOCKED (on object monitor) at java.util.stream.FindOps$FindTask.makeChild(FindOps.java:268) at java.util.stream.FindOps$FindTask.makeChild(FindOps.java:249) at java.util.stream.AbstractShortCircuitTask.compute(AbstractShortCircuitTask.java:120) at java.util.concurrent.CountedCompleter.exec(CountedCompleter.java:731) at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289) at java.util.concurrent.ForkJoinPool.helpComplete(ForkJoinPool.java:1870) at java.util.concurrent.ForkJoinPool.awaitJoin(ForkJoinPool.java:2045) at java.util.concurrent.ForkJoinTask.doInvoke(ForkJoinTask.java:404) at java.util.concurrent.ForkJoinTask.invoke(ForkJoinTask.java:734) at java.util.stream.FindOps$FindOp.evaluateParallel(FindOps.java:159) at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:233) at java.util.stream.ReferencePipeline.findAny(ReferencePipeline.java:469) at com.egova.wukong.service.impl.PageServiceImpl.lambda$getPageCards$22(PageServiceImpl.java:571) at com.egova.wukong.service.impl.PageServiceImpl$$Lambda$1107/1403252310.apply(Unknown Source) at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) at java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948) at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) at java.util.stream.ReduceOps$ReduceTask.doLeaf(ReduceOps.java:747) at java.util.stream.ReduceOps$ReduceTask.doLeaf(ReduceOps.java:721) at java.util.stream.AbstractTask.compute(AbstractTask.java:316) at java.util.concurrent.CountedCompleter.exec(CountedCompleter.java:731) at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289) at java.util.concurrent.ForkJoinPool$WorkQueue.execLocalTasks(ForkJoinPool.java:1040) at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1058) at java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692) at java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)&quot;ForkJoinPool.commonPool-worker-7&quot; #145 daemon prio=5 os_prio=0 tid=0x00007fd0880ba000 nid=0x632f waiting for monitor entry [0x00007fd0720e5000] java.lang.Thread.State: BLOCKED (on object monitor) at java.util.stream.FindOps$FindTask.makeChild(FindOps.java:268) at java.util.stream.FindOps$FindTask.makeChild(FindOps.java:249) at java.util.stream.AbstractShortCircuitTask.compute(AbstractShortCircuitTask.java:119) at java.util.concurrent.CountedCompleter.exec(CountedCompleter.java:731) at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289) at java.util.concurrent.ForkJoinPool.helpComplete(ForkJoinPool.java:1870) at java.util.concurrent.ForkJoinPool.awaitJoin(ForkJoinPool.java:2045) at java.util.concurrent.ForkJoinTask.doInvoke(ForkJoinTask.java:404) at java.util.concurrent.ForkJoinTask.invoke(ForkJoinTask.java:734) 错误日志指向ForkJoinTask，线程发生阻塞。项目代码 12345678910111213141516171819 .....List&lt;CardData&gt; finalCardDataList = cardDataList;return pageCards.parallelStream() //第一次并行流 .sorted(Comparator.comparingInt(PageCard::getLevel).reversed()) .map(pageCard -&gt; &#123; PageCardModel pageCardModel = new PageCardModel(); pageCardModel.setBase(cards.parallelStream() //第二次并行流 .filter(card -&gt; StringUtils.equals(card.getId(), pageCard.getCardId())).findAny().orElse(null)); pageCardModel.setData(finalCardDataList.parallelStream() //第三次并行流 .filter(cardData -&gt; StringUtils.equals(cardData.getId(), pageCard.getDataId())).findAny().orElse(null)); pageCardModel.setStyle(pageCard.getStyle()); pageCardModel.setId(pageCard.getId()); pageCardModel.setName(pageCard.getName()); return pageCardModel; &#125;).collect(Collectors.toList());&#125;parallelStream流内，嵌套两层，并返回大json数据，导致线程占满，IO阻塞 2. 初步推测并行流陷阱 线程安全 由于并行流使用多线程，则一切线程安全问题都应该是需要考虑的问题，如：资源竞争、死锁、事务、可见性等等 线程消费 在虚拟机启动时，我们指定了worker线程的数量，整个程序的生命周期都将使用这些工作线程；这必然存在任务生产和消费的问题，如果某个生产者生产了许多重量级的任务（耗时很长），那么其他任务毫无疑问将会没有工作线程可用；更可怕的事情是这些工作线程正在进行IO阻塞。 3.设置并行参数我们可以通过虚拟机启动参数，控制ForkJoinPool的线程数-Djava.util.concurrent.ForkJoinPool.common.parallelism&#x3D;N 来设置worker的数量。 4. 扩展parallelStreams()，使用ForkJoinPool。资源耗尽时使用线程池的默认拒绝策略，在默认的ThreadPoolExecutor.AbortPolicy中，处理程序抛出一个拒绝后运行时RejectedExecutionException。 4. 小结串行流：适合存在线程安全问题、阻塞任务、重量级任务，以及需要使用同一事务的逻辑。 并行流：适合没有线程安全问题、较单纯的数据处理任务。","categories":[],"tags":[]},{"title":"windows下搭建hexo博客","slug":"win10下搭建hexo博客","date":"2022-03-18T14:53:55.000Z","updated":"2022-03-25T16:06:54.775Z","comments":true,"path":"2022/03/18/win10下搭建hexo博客/","link":"","permalink":"https://example.com/2022/03/18/win10%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/","excerpt":"[TOC]","text":"[TOC] 1.安装nodejs略 2.切换淘宝源(有梯子则不切换)：npm install -g cnpm –registry &#x3D;https://registry.npm.taobao.org 3.安装hexo:cnpm install -g hexo-cli 4.使用hexo搭建。 新建blog文件夹 初始化sudo hexo init或 hexo init windows管理员权限出现问题。hexo : 无法加载文件 C:\\Users\\xxx\\AppData\\Roaming\\npm\\hexo.ps1，因为在此系统上禁止运行脚本。 解决方案在默认情况下，我们是无法执行powershell脚本的， 需要更改执行策略。win10下更改执行策略：1.打开设置 2.搜索power 选择选项：允许本地powershell在不签名的情况下运行3.勾选，点击应用就可以了 5.启动hexo s 6.github新建仓库。仓库名必须是 用户名.github.io 例如junjieliao593新建的仓库名为：junjieliao593.github.io.git 7.本地下载git插件 cnpm install –save hexo-deployer-git 8.设置blog目录下__cofig.yml配置。 Deloyment配置git仓库地址及分支 deploy:type: gitrepo: https://github.com/junjieliao593/junjieliao593.github.iobranch: master 9.部署发布hexo d 10.访问junjieliao593.github.io 11.主题https://github.com/litten/hexo-theme-yilia git clone https://github.com/litten/hexo-theme-yilia.git themes&#x2F;yilia 修改blog目录下_config.yml配置： theme: yilia 清理hexo clean 重构hexo g 预览hexo s 推到远程仓库hexo d 其他主题https://github.com/theme-next/hexo-theme-next 12.编辑文章md文件存放在 blog\\source_posts目录下，用其他编辑器操作即可。 13. 后续可参考文档官方文档： https://hexo.io/zh-cn/docs/完成操作文档(包含多终端工作指南)： https://blog.csdn.net/sinat_37781304/article/details/82729029 补充推荐一个很好看的主题，也是当前本人博客所用的主题，有比较详细的中文文档，https://mengd.js.org/","categories":[{"name":"hexo使用","slug":"hexo使用","permalink":"https://example.com/categories/hexo%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://example.com/tags/hexo/"}]}],"categories":[{"name":"hexo使用","slug":"hexo使用","permalink":"https://example.com/categories/hexo%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://example.com/tags/hexo/"}]}